# Generates headers that declares all uking symbols
import os, csv, sys
from common import mangleDataName, mangleFunctionName

# consts
CUSTOM_HEADER = """
/*
 *  This is a generated file
 *  DO NOT EDIT THIS FILE DIRECTLY
 *  Generate with genBotwSymbols.py instead
 */

"""

# Namespace for the generated header
HPP_NAMESPACE = "KingSymbols150"
# Prefix function name
FUNC_PREFIX = "f_"
# Prefix Data symbols
DATA_PREFIX = "d_"
# Address Prefix to strip (and check)
ADDR_PREFIX = "0x00000071"
# LinkerHints
LINKER_HINTS = "Links"

UKING_FUNCTIONS = "libs/botw/data/uking_functions.csv"
UKING_DATA_SYMBOLS = "libs/botw/data/data_symbols.csv"
HPP_OUTPUT = f"include/{HPP_NAMESPACE}.hpp"

def addFunctionDeclaration(hppLines, addrStr, funcName):
    cleanName = cleanFunctionName(funcName)
    mangledName = mangleFunctionName(cleanName)
    comment = f"/* {LINKER_HINTS} {addrStr} {mangledName} ({funcName}) */\n"
    declaration = f"extern void {cleanName}();\n"

    hppLines.append(comment)
    hppLines.append(declaration)

def addDataDeclaration(hppLines, addrStr, dataName):
    cleanName = cleanDataName(dataName)
    mangledName = mangleDataName(cleanName)
    comment = f"/* {LINKER_HINTS} {addrStr} {mangledName} ({dataName}) */\n"
    declaration = f"extern void* {cleanName};\n"

    hppLines.append(comment)
    hppLines.append(declaration)

def cleanFunctionName(funcName):
    return FUNC_PREFIX + cleanSymbolName(funcName)

def cleanDataName(dataName):
    return DATA_PREFIX + cleanSymbolName(dataName)

def cleanSymbolName(name):
    name = name.replace("::", "__")
    name = name.replace(".", "_")
    return name

# Strip the 0x0...071
def parseAddress(rawAddr):
    if not rawAddr.startswith(ADDR_PREFIX):
        return None
    return "0x" + rawAddr[len(ADDR_PREFIX):]

hppLines = []
addrSet = set() # Used for checking duplicates
funcCount = 0
dataCount = 0

# Read CSV
print("Reading", UKING_FUNCTIONS)
with open(UKING_FUNCTIONS) as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        # Skip invalid rows
        if len(row) < 4:
            continue
        rawAddr = row[0]
        # Skip the headers
        if rawAddr == "Address":
            continue
        funcName = row[3]
        if len(funcName) > 0:
            addrStr = parseAddress(rawAddr)
            if addrStr == None:
                print("Error: Invalid Address: ", rawAddr)
                continue
            if addrStr in addrSet:
                print("Error: Duplicate Address: ", rawAddr)
                continue
            addrSet.add(addrStr)
            addFunctionDeclaration(hppLines, addrStr, funcName)
            funcCount+=1
print("Found ", funcCount, "function symbols")

print("Reading", UKING_DATA_SYMBOLS)
with open(UKING_DATA_SYMBOLS) as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        # Skip invalid rows
        if len(row) < 2:
            continue
        rawAddr = row[0]
        dataName = row[1]
        if len(dataName) > 0:
            addrStr = parseAddress(rawAddr)
            if addrStr == None:
                print("Error: Invalid Address: ", rawAddr)
                continue
            if addrStr in addrSet:
                print("Error: Duplicate Address: ", rawAddr)
                continue
            addrSet.add(addrStr)
            addDataDeclaration(hppLines, addrStr, dataName)
            dataCount+=1
print("Found ", dataCount, "data symbols")

# Write Hpp
print("Writing", HPP_OUTPUT)
with open(HPP_OUTPUT, "w+") as hppFile:
    hppFile.write(f"/* {HPP_OUTPUT} */\n")
    hppFile.write(CUSTOM_HEADER)

    hppFile.write(f"namespace {HPP_NAMESPACE} {{\n")
    hppFile.writelines(hppLines)
    hppFile.write("}\n")

print("Written", funcCount+dataCount, "symbols")
